#### Yocto
- Linuxディストリビューションを作るフレームワーク
  - 世界中の機能（コンポーネント）を定義するRecipe
  - レシピを層状にまとめたLayers
  - コンフィギュレーションファイル（*.conf）
- 自社製品に最適化された組み込みLinuxディストリビューションを入手できる
  - 製品機能に必要なコンポーネントを柔軟に選択できる
  - 基盤やハードウェアの性能要件に合わせてコンポーネントを選択できる
- 各種ビルドツール（bitbakeなど）も統合されている
  - Linuxディストリビューションの定義、生成、ビルド、デプロイの全工程に対応
- 様々なリファレンスボード向けのBSP（Board-SupportPackage）を提供している

#### netlink
[netlink - 約束事その他の説明 - Linux コマンド集 一覧表](https://kazmax.zpp.jp/cmd/n/netlink.7.html)
- カーネルモジュールとユーザー空間のプロセス間での通信  
  ※双方向の通信
- ユーザープロセスに対しては標準的なソケットベースのインターフェースを提供
- カーネルモジュールには内部APIを提供
- netlinkメッセージはバイトストリームからなり、１つ以上のnlmsghdr（netlinkメッセージヘッダ）と対応するpayload（データの実態）が含まれる。
  - バイトストリームへのアクセスは標準の`NLMSG_*`マクロによって行う  
  - nlmsghdrの構造は以下  
    ※32bitずつの塊にして送信するのでタイプと追加フラグは１かたまりになる
  ```
  struct nlmsghdr {
     __u32 nlmsg_len;    /* ヘッダーを含むメッセージの長さ （= nlmsghdr + padding + payload）*/
     __u16 nlmsg_type;   /* メッセージの内容のタイプ （標準形は/usr/include/linux/netlink.hで定義されている）*/
     __u16 nlmsg_flags;  /* 追加フラグ */
     __u32 nlmsg_seq;    /* シーケンス番号 （プロセスの何個目の通信要求か）*/
     __u32 nlmsg_pid;    /* 送信者のポート ID (どのプロセスが要求した通信か）*/
  };
  ```
  - nlmsg_type  
    - NLMSG_NOOP:     アクションなし（NLMSG_NOOPが届き続けた後にNLMSG_DONEが届くことは全ての通信が成功したことを意味する）
    - NLMSG_ERROR:    エラーメッセージ（送信したメッセージに対する返答としてこれが帰ってくることはリクエストの失敗を意味する）
    - NLMSG_DONE:     現在のnetlinkメッセージ群中最後のメッセージであること
    - NLMSG_OVERRUN:  （現在使われていない）  
    ※ユーザ定義も可能。但し値は16（0x10）以上でなければいけない（16未満は他で使用されている）
    
  - nlmsg_flags  
    ※フラグは複数設定することが可能（ビットAND/OR） 
    - NLM_F_REQUEST:  当該netlinkメッセージにリクエストが含まれること。ユーザースペース→カーネルの通信にセットされる（ないとカーネルからEINVALエラーが返ってくる）
    - NLM_F_CREATE:   ユーザスペースのプロセスがカーネルサブシステムにリソースや設定を作成することを命令する
    - NLM_F_EXCL:     NLM_F_CREATEと同時に使用し、既にリソースや設定が存在する場合にエラーを返す
    - NLM_F_REPLACE:  カーネル空間のサブシステムの既存設定を置き換える
    - NLM_F_APPEND:   カーネル空間の既存設定にデータの追加を要求する（既存のリンクリストにデータを追加する等）
    - NLM_F_DUMP:     カーネル空間の特定タイプのデータを全てユーザー空間側に返すように要求する。カーネルは複数の連続したnetlinkメッセージをユーザー空間に返す
    - NLM_F_MULTI:    メッセージの受け取り側に、当該netlinkメッセージの後にもnetlinkメッセージが存在することを伝える
    - NLM_F_ACK:      ユーザー空間からカーネル空間に、リクエストの完了通知を返すように要求する（カーネルはNLMSG_NOOPかNLMSG_ERRORを付けて返答する）  
    ※nlmsg_flagsより以下のことがわかる
    - ユーザー空間のプロセスが基本的にリクエスト側（命令を出す側）
    - カーネルは基本的に処理をする側（プロセスの命令に対して処理を実行する側）
    - 殆どの場合、ユーザープロセスがカーネルとの通信を開始する
      - イベント契機の通知（カーネルが削除されたことを通知する等）に関してはカーネルが通信を開始する
  
  - nlmsg_seq
    - ユーザー空間のプロセスからカーネルにNLM_F_ACKフラグを持ったメッセージを送付する場合に必要
    - カーネルから応答する時に、要求メッセージと同一のシーケンス番号を付与して送り返す
    - 複数のリクエストに対して応答待ちの状態になっている時に、届いたメッセージがどのリクエストに対応するものか判断するために必要
  
  - nlmsg_pid
    - カーネル空間にメッセージを送信する時にユーザー空間のプロセス側でセットされる
    - カーネル側から応答する時にどのプロセス（アプリケーション）宛にすれば良いか判断できる
    - カーネル側で開始された通信でユーザー空間のプロセスにメッセージを送付する場合は0がセットされる（カーネルはプロセス番号を知るすべを持たない）
